<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ohmsches Gesetz Trainer</title>
    <style>
      :root {
        color-scheme: only light;
        --ink: #1d2b2b;
        --muted: #526266;
        --panel: #f9f6ef;
        --accent: #0f6b65;
        --accent-2: #c76a2d;
        --wire: #39474a;
        --card: #ffffff;
        --shadow: 0 24px 60px rgba(20, 35, 35, 0.15);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Trebuchet MS", "Gill Sans", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at top, rgba(199, 106, 45, 0.18), transparent 55%),
          radial-gradient(circle at 10% 20%, rgba(15, 107, 101, 0.16), transparent 48%),
          linear-gradient(135deg, #f4efe2 0%, #e8efe9 100%);
        min-height: 100vh;
      }

      .page {
        max-width: 1100px;
        margin: 32px auto 40px;
        padding: 0 20px 40px;
        animation: fade-in 0.8s ease;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        gap: 24px;
        align-items: center;
        justify-content: space-between;
        padding: 28px 28px 20px;
        background: var(--card);
        border-radius: 22px;
        box-shadow: var(--shadow);
        position: relative;
        overflow: hidden;
      }

      header::after {
        content: "";
        position: absolute;
        right: -120px;
        top: -120px;
        width: 260px;
        height: 260px;
        background: radial-gradient(circle, rgba(15, 107, 101, 0.2), transparent 70%);
        border-radius: 50%;
      }

      h1 {
        margin: 0 0 8px;
        font-family: "Georgia", "Times New Roman", serif;
        font-size: clamp(28px, 3vw, 36px);
        letter-spacing: 0.4px;
      }

      header p {
        margin: 0;
        color: var(--muted);
        max-width: 520px;
      }

      .formula-badge {
        background: #f0ede4;
        border: 2px solid rgba(15, 107, 101, 0.2);
        padding: 14px 18px;
        border-radius: 16px;
        font-family: "Georgia", "Times New Roman", serif;
        font-size: 22px;
        color: var(--accent);
        box-shadow: inset 0 0 0 1px rgba(199, 106, 45, 0.2);
      }

      .controls {
        margin-top: 14px;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      .controls label {
        font-weight: 600;
      }

      select,
      input {
        font: inherit;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(29, 43, 43, 0.25);
        background: #fffdf7;
      }

      .panel {
        margin-top: 24px;
        display: grid;
        grid-template-columns: minmax(0, 1.05fr) minmax(0, 0.95fr);
        gap: 22px;
      }

      .card {
        background: var(--card);
        border-radius: 20px;
        box-shadow: var(--shadow);
        padding: 22px;
      }

      .circuit-wrap {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      #circuit {
        width: 100%;
        height: 480px;
        border-radius: 16px;
        background: linear-gradient(120deg, #fff8ea, #f2f7f4);
        border: 1px solid rgba(29, 43, 43, 0.12);
      }

      .legend {
        font-size: 14px;
        color: var(--muted);
        display: flex;
        flex-wrap: wrap;
        gap: 8px 16px;
      }

      .legend span {
        padding: 4px 8px;
        border-radius: 8px;
        background: rgba(15, 107, 101, 0.08);
      }

      .task-title {
        font-size: 20px;
        margin: 0 0 10px;
      }

      .task-text {
        font-size: 16px;
        margin-bottom: 12px;
      }

      .given {
        background: var(--panel);
        border-radius: 14px;
        padding: 12px 14px;
        margin-bottom: 16px;
        color: var(--muted);
      }

      .given ul {
        margin: 0;
        padding-left: 18px;
      }

      .input-row {
        display: grid;
        gap: 12px;
        align-items: end;
        grid-template-columns: 1.1fr auto;
      }

      .input-row label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
      }

      .input-wrap {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .input-wrap span {
        font-weight: 600;
        color: var(--accent);
      }

      button {
        font: inherit;
        border: none;
        border-radius: 12px;
        padding: 12px 16px;
        cursor: pointer;
        background: var(--accent);
        color: white;
        font-weight: 600;
        box-shadow: 0 12px 24px rgba(15, 107, 101, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      button.secondary {
        background: #fff3e5;
        color: var(--accent-2);
        box-shadow: none;
        border: 1px solid rgba(199, 106, 45, 0.4);
      }

      button:hover {
        transform: translateY(-1px);
      }

      .feedback {
        margin-top: 14px;
        font-weight: 600;
      }

      .feedback.good {
        color: #1a7f63;
      }

      .feedback.bad {
        color: #b8452c;
      }

      .solution {
        margin-top: 12px;
        border-top: 1px dashed rgba(29, 43, 43, 0.2);
        padding-top: 12px;
        color: var(--muted);
      }

      .solution-block {
        margin-bottom: 10px;
      }

      .solution-title {
        font-weight: 600;
        color: var(--ink);
        margin-bottom: 4px;
      }

      .rank-panel {
        position: relative;
        background: #f7f0e1;
        border-radius: 16px;
        padding: 14px;
        border: 1px solid rgba(29, 43, 43, 0.1);
        margin-bottom: 16px;
      }

      .rank-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .rank-label {
        font-size: 12px;
        letter-spacing: 0.6px;
        text-transform: uppercase;
        color: var(--muted);
      }

      .rank-name {
        font-size: 20px;
        font-weight: 700;
        color: var(--accent);
      }

      .rank-count {
        text-align: right;
        font-weight: 700;
        color: var(--accent-2);
      }

      .rank-count span {
        display: block;
      }

      .rank-progress {
        margin-top: 10px;
      }

      .rank-bar {
        height: 8px;
        background: #e7dec9;
        border-radius: 999px;
        overflow: hidden;
      }

      .rank-fill {
        height: 100%;
        width: 0%;
        background: var(--accent);
        transition: width 0.3s ease;
      }

      .rank-next {
        font-size: 12px;
        margin-top: 6px;
        color: var(--muted);
      }

      .rank-select {
        margin-top: 10px;
      }

      .rank-select label {
        display: block;
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 6px;
      }

      .rank-select-row {
        display: grid;
        gap: 8px;
        align-items: center;
        grid-template-columns: minmax(0, 1fr) auto;
      }

      .rank-select-row select {
        min-width: 0;
      }

      .rank-message {
        margin-top: 8px;
        font-weight: 600;
        color: var(--accent-2);
      }

      .rank-celebrate {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
      }

      .rank-star {
        position: absolute;
        font-size: 18px;
        color: var(--accent-2);
        opacity: 0;
        animation: rank-pop 1.1s ease forwards;
      }

      @keyframes rank-pop {
        0% {
          transform: translateY(0) scale(0.2);
          opacity: 0;
        }
        30% {
          opacity: 1;
        }
        100% {
          transform: translateY(-60px) scale(1);
          opacity: 0;
        }
      }

      .calc {
        margin-top: 16px;
        background: #f6f2e7;
        border-radius: 16px;
        padding: 16px;
        border: 1px solid rgba(29, 43, 43, 0.1);
      }

      .calc h3 {
        margin: 0 0 6px;
        font-size: 18px;
      }

      .calc-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .calc-toggle {
        display: inline-flex;
        background: #fff7e8;
        border-radius: 999px;
        border: 1px solid rgba(199, 106, 45, 0.35);
        overflow: hidden;
      }

      .calc-toggle button {
        background: transparent;
        border: none;
        padding: 6px 12px;
        font-weight: 700;
        color: var(--accent-2);
        box-shadow: none;
      }

      .calc-toggle button.is-active {
        background: var(--accent-2);
        color: #fffaf2;
      }

      .calc-help {
        margin: 0 0 12px;
        font-size: 14px;
        color: var(--muted);
      }

      .calc-variant {
        margin-top: 12px;
      }

      .calc-controls {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        align-items: end;
      }

      .calc-field label {
        display: block;
        font-size: 13px;
        font-weight: 600;
        margin-bottom: 6px;
      }

      .calc-actions {
        margin-top: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .calc-display {
        margin-top: 12px;
        background: #fffdf7;
        border-radius: 12px;
        padding: 10px 12px;
        border: 1px dashed rgba(29, 43, 43, 0.25);
      }

      .calc-current,
      .calc-line {
        font-family: "Courier New", "Lucida Console", monospace;
        font-size: 14px;
      }

      .calc-lines {
        margin-top: 6px;
      }

      .calc-preview {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-family: "Courier New", "Lucida Console", monospace;
        font-size: 14px;
        color: var(--muted);
      }

      .calc-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .calc-row-actions {
        display: inline-flex;
        gap: 8px;
        align-items: center;
      }

      .calc-row button {
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
      }

      .calc-message {
        margin-top: 8px;
        font-size: 13px;
        color: #b8452c;
      }

      .is-hidden {
        display: none;
      }

      .tips {
        margin-top: 22px;
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }

      .tip {
        background: #f3f0e8;
        padding: 14px 16px;
        border-radius: 14px;
        font-size: 14px;
        color: var(--muted);
        border: 1px solid rgba(29, 43, 43, 0.08);
      }

      .tip strong {
        color: var(--accent);
      }

      @keyframes fade-in {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 900px) {
        .panel {
          grid-template-columns: 1fr;
        }

        .input-row {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="page">
      <header>
        <div>
          <h1>Ohmsches Gesetz Trainer</h1>
          <p>
            Trainiere U = R * I mit zufaelligen Schaltplaenen. Jeder Klick erzeugt
            eine neue Aufgabe fuer Spannung, Stromstaerke oder Widerstand.
          </p>
          <div class="controls">
            <label for="modeSelect">Gesuchte Groesse:</label>
            <select id="modeSelect">
              <option value="random">Zufaellig</option>
              <option value="U">U (Spannung)</option>
              <option value="I">I (Stromstaerke)</option>
              <option value="R">R (Widerstand)</option>
            </select>
          </div>
        </div>
        <div class="formula-badge">U = R * I</div>
      </header>

      <section class="panel">
        <div class="card circuit-wrap">
          <svg id="circuit" viewBox="0 0 640 480" aria-label="Schaltplan"></svg>
          <div class="legend" id="circuitLegend"></div>
        </div>

        <div class="card">
          <div class="rank-panel" id="rankPanel">
            <div class="rank-header">
              <div>
                <div class="rank-label">Dein Rang</div>
                <div class="rank-name" id="rankName">0-Newbie</div>
              </div>
              <div class="rank-count">
                <span id="rankCount">0</span>
                <span>Richtig</span>
              </div>
            </div>
            <div class="rank-progress">
              <div class="rank-bar">
                <div class="rank-fill" id="rankFill"></div>
              </div>
              <div class="rank-next" id="rankNext"></div>
            </div>
            <div class="rank-select">
              <label for="rankSelect">Letzten Rang setzen</label>
              <div class="rank-select-row">
                <select id="rankSelect"></select>
                <button type="button" class="secondary" id="rankApplyBtn">Uebernehmen</button>
              </div>
            </div>
            <div class="rank-message" id="rankMessage"></div>
            <div class="rank-celebrate" id="rankCelebrate"></div>
          </div>
          <h2 class="task-title">Aufgabe</h2>
          <div class="task-text" id="taskText"></div>
          <div class="given" id="givenText"></div>

          <div class="input-row">
            <div>
              <label for="answerInput">Dein Ergebnis</label>
              <div class="input-wrap">
                <input id="answerInput" type="text" placeholder="z.B. 12,5">
                <span id="unitLabel"></span>
              </div>
            </div>
            <div>
              <button type="button" id="checkBtn">Pruefen</button>
              <button type="button" class="secondary" id="newBtn">Neue Aufgabe</button>
            </div>
          </div>

          <div class="feedback" id="feedback"></div>
          <div class="solution" id="solution"></div>
          <div class="calc" id="calc">
            <div class="calc-header">
              <h3>Rechenweg im Browser</h3>
              <div class="calc-toggle" role="group" aria-label="Rechenweg Variante">
                <button type="button" class="is-active" data-variant="0">0</button>
                <button type="button" data-variant="1">1</button>
                <button type="button" data-variant="2">2</button>
              </div>
            </div>

            <div class="calc-variant" id="calcVariant1">
              <p class="calc-help">
                Schreibe eine ganze Zeile, z.B. "1/50 + 1/60" (auch "1-50" wird als 1/50 gelesen).
                Druecke "Ausrechnen", um die Zeile ins Log zu uebernehmen.
              </p>
              <div class="calc-controls">
                <div class="calc-field">
                  <label for="simpleExpr">Rechenzeile</label>
                  <input id="simpleExpr" type="text" placeholder="z.B. 1/50 + 1/60">
                </div>
              </div>
              <div class="calc-actions">
                <button type="button" class="secondary" id="simpleCalcBtn">Ausrechnen</button>
              </div>
              <div class="calc-display">
                <div class="calc-preview" id="simpleCalcPreview">Vorschau: (leer)</div>
                <div class="calc-lines" id="simpleCalcLines"></div>
              </div>
              <div class="calc-message" id="simpleCalcMessage"></div>
            </div>

            <div class="calc-variant is-hidden" id="calcVariant2">
              <p class="calc-help">
                Baue eine Rechnung Schritt fuer Schritt. Der Operator danach bestimmt, wie es weitergeht; "=" beendet
                eine Zeile. Die Vorschau aktualisiert sofort, "Rechnungszeile beenden" speichert die Zeile.
              </p>
              <div class="calc-controls">
                <div class="calc-field">
                  <label for="termType">Wertauswahl</label>
                  <select id="termType">
                    <option value="number">Zahl</option>
                    <option value="reciprocal">1 / Zahl</option>
                    <option value="known">Bekannter Wert</option>
                    <option value="reciprocalKnown">1 / bekannter Wert</option>
                    <option value="last">Letztes Ergebnis</option>
                    <option value="reciprocalLast">1 / letztes Ergebnis</option>
                  </select>
                </div>
                <div class="calc-field" id="termValueField">
                  <label for="termValue">Zahl</label>
                  <input id="termValue" type="text" placeholder="z.B. 50">
                </div>
                <div class="calc-field is-hidden" id="knownValueField">
                  <label for="knownValue">Bekannter Wert</label>
                  <select id="knownValue"></select>
                </div>
                <div class="calc-field">
                  <label for="operatorSelect">Operator danach</label>
                  <select id="operatorSelect">
                    <option value="+">+</option>
                    <option value="-">-</option>
                    <option value="*">*</option>
                    <option value="/">/</option>
                    <option value="=">=</option>
                  </select>
                </div>
              </div>
              <div class="calc-actions">
                <button type="button" class="secondary" id="calcAddTermBtn">Wert hinzufuegen</button>
                <button type="button" class="secondary" id="calcFinishBtn">Rechnungszeile beenden</button>
                <button type="button" class="secondary" id="calcUndoBtn">Rueckgaengig</button>
              </div>
              <div class="calc-display">
                <div class="calc-preview" id="calcPreview2">Vorschau: (leer)</div>
                <div class="calc-current" id="calcCurrent">Aktuelle Zeile: (leer)</div>
                <div class="calc-lines" id="calcLines"></div>
              </div>
              <div class="calc-message" id="calcMessage"></div>
            </div>
          </div>
        </div>
      </section>

      <section class="tips">
        <div class="tip">
          <strong>Tipp:</strong> Reihenschaltung: Widerstaende addieren.
        </div>
        <div class="tip">
          <strong>Tipp:</strong> Parallelschaltung: 1 / Rges = Summe(1 / Ri).
        </div>
        <div class="tip">
          <strong>Tipp:</strong> Nutze U = R * I oder eine Umstellung davon.
        </div>
      </section>
    </main>

    <script>
      const RESISTOR_VALUES = [10, 15, 20, 30, 50, 60, 100, 120, 150, 200, 300];
      const LAMP_RESISTANCE = 60;
      const VOLTAGES = [3, 4.5, 6, 9, 12, 18, 24];
      const CURRENTS = [0.1, 0.2, 0.25, 0.5, 0.75, 1.0];
      const RANKS = [
        { threshold: 0, name: "0-Newbie" },
        { threshold: 5, name: "1-Ohm-Rookie" },
        { threshold: 10, name: "2-Unruh" },
        { threshold: 20, name: "3-Voltage Pro" },
        { threshold: 30, name: "4-Circuit Master" },
        { threshold: 40, name: "5-Resistance Ranger" },
        { threshold: 50, name: "6-Power Driver" },
        { threshold: 75, name: "7-Ohm-Legend" },
        { threshold: 100, name: "8-Ultra-Physics-Calculation-Man" },
      ];
      const STORAGE_KEY = "physicsTrainerCorrectCount";

      const modeSelect = document.getElementById("modeSelect");
      const taskText = document.getElementById("taskText");
      const givenText = document.getElementById("givenText");
      const unitLabel = document.getElementById("unitLabel");
      const answerInput = document.getElementById("answerInput");
      const feedback = document.getElementById("feedback");
      const solution = document.getElementById("solution");
      const circuitSvg = document.getElementById("circuit");
      const circuitLegend = document.getElementById("circuitLegend");
      const rankName = document.getElementById("rankName");
      const rankCount = document.getElementById("rankCount");
      const rankFill = document.getElementById("rankFill");
      const rankNext = document.getElementById("rankNext");
      const rankSelect = document.getElementById("rankSelect");
      const rankApplyBtn = document.getElementById("rankApplyBtn");
      const rankMessage = document.getElementById("rankMessage");
      const rankCelebrate = document.getElementById("rankCelebrate");
      const calcToggleButtons = Array.from(document.querySelectorAll(".calc-toggle button"));
      const calcVariant1 = document.getElementById("calcVariant1");
      const calcVariant2 = document.getElementById("calcVariant2");
      const simpleExpr = document.getElementById("simpleExpr");
      const simpleCalcBtn = document.getElementById("simpleCalcBtn");
      const simpleCalcLines = document.getElementById("simpleCalcLines");
      const simpleCalcMessage = document.getElementById("simpleCalcMessage");
      const simpleCalcPreview = document.getElementById("simpleCalcPreview");
      const termType = document.getElementById("termType");
      const termValue = document.getElementById("termValue");
      const termValueField = document.getElementById("termValueField");
      const knownValueField = document.getElementById("knownValueField");
      const knownValueSelect = document.getElementById("knownValue");
      const operatorSelect = document.getElementById("operatorSelect");
      const calcAddTermBtn = document.getElementById("calcAddTermBtn");
      const calcFinishBtn = document.getElementById("calcFinishBtn");
      const calcUndoBtn = document.getElementById("calcUndoBtn");
      const calcCurrent = document.getElementById("calcCurrent");
      const calcLines = document.getElementById("calcLines");
      const calcMessage = document.getElementById("calcMessage");
      const calcPreview2 = document.getElementById("calcPreview2");

      let currentTask = null;
      let taskInitialized = false;
      let taskSolved = false;
      let correctCount = 0;
      let currentRankIndex = 0;
      let knownValues = [];
      let activeCalcVariant = "0";
      const simpleCalcState = {
        lines: [],
        lastResult: null,
      };
      const calcState = {
        lines: [],
        currentTokens: [],
        lastResult: null,
      };

      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function pick(list) {
        return list[randomInt(0, list.length - 1)];
      }

      function formatNumber(value, decimals = 2) {
        const rounded = Number(value.toFixed(decimals));
        const text = rounded.toFixed(decimals).replace(/\.?0+$/, "");
        return text.replace(".", ",");
      }

      function parseInput(value) {
        if (!value) return NaN;
        return Number(value.replace(",", "."));
      }

      function readStoredCount() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          const value = Number(stored);
          return Number.isFinite(value) ? value : 0;
        } catch (error) {
          return 0;
        }
      }

      function writeStoredCount(count) {
        try {
          localStorage.setItem(STORAGE_KEY, String(count));
        } catch (error) {
          // Ignore storage errors in restricted environments.
        }
      }

      function getRankIndex(count) {
        let index = 0;
        RANKS.forEach((rank, i) => {
          if (count >= rank.threshold) {
            index = i;
          }
        });
        return index;
      }

      function populateRankSelect() {
        rankSelect.innerHTML = RANKS.map(
          (rank, index) => `<option value="${index}">${rank.name}</option>`
        ).join("");
      }

      function updateRankUi(celebrate) {
        const previousRank = currentRankIndex;
        currentRankIndex = getRankIndex(correctCount);
        const currentRank = RANKS[currentRankIndex];
        const nextRank = RANKS[currentRankIndex + 1] || null;
        const progress = nextRank
          ? (correctCount - currentRank.threshold) / (nextRank.threshold - currentRank.threshold)
          : 1;

        rankName.textContent = currentRank.name;
        rankCount.textContent = String(correctCount);
        rankFill.style.width = `${Math.min(Math.max(progress, 0), 1) * 100}%`;
        rankSelect.value = String(currentRankIndex);
        if (nextRank) {
          const remaining = Math.max(0, nextRank.threshold - correctCount);
          rankNext.textContent = `Naechster Rang: ${nextRank.name} in ${remaining} Aufgaben`;
        } else {
          rankNext.textContent = "Maximaler Rang erreicht.";
        }

        if (celebrate && currentRankIndex > previousRank) {
          rankMessage.textContent = `Neuer Rang freigeschaltet: ${currentRank.name}`;
          triggerRankCelebration();
        } else {
          rankMessage.textContent = "";
        }
      }

      function triggerRankCelebration() {
        rankCelebrate.innerHTML = "";
        for (let i = 0; i < 14; i += 1) {
          const star = document.createElement("div");
          star.className = "rank-star";
          star.textContent = "*";
          const left = randomInt(10, 90);
          const top = randomInt(40, 90);
          const size = randomInt(12, 22);
          const delay = Math.random() * 0.2;
          star.style.left = `${left}%`;
          star.style.top = `${top}%`;
          star.style.fontSize = `${size}px`;
          star.style.animationDelay = `${delay}s`;
          rankCelebrate.appendChild(star);
        }
      }

      function applyRankSelection() {
        const index = Number(rankSelect.value);
        if (!Number.isFinite(index) || !RANKS[index]) {
          return;
        }
        correctCount = RANKS[index].threshold;
        writeStoredCount(correctCount);
        updateRankUi(false);
        rankMessage.textContent = "Rang gesetzt.";
      }

      function registerCorrectAnswer() {
        if (taskSolved) return;
        taskSolved = true;
        correctCount += 1;
        writeStoredCount(correctCount);
        updateRankUi(true);
      }

      function setCalcVariant(variant) {
        activeCalcVariant = variant;
        calcToggleButtons.forEach((button) => {
          button.classList.toggle("is-active", button.dataset.variant === variant);
        });
        calcVariant1.classList.toggle("is-hidden", variant !== "1");
        calcVariant2.classList.toggle("is-hidden", variant !== "2");
      }

      function sanitizeExpression(raw) {
        let text = raw.toLowerCase();
        text = text.replace(/,/g, ".");
        text = text.replace(/\bplus\b/g, "+");
        text = text.replace(/\bminus\b/g, "-");
        text = text.replace(/\bmal\b/g, "*");
        text = text.replace(/\bgeteilt\b/g, "/");
        text = text.replace(/\bdurch\b/g, "/");
        text = text.replace(/\b1-(\d+(?:\.\d+)?)\b/g, "1/$1");
        text = text.replace(/x/g, "*");
        text = text.replace(/:/g, "/");
        return text.replace(/[^0-9+\-*/().\s]/g, "").trim();
      }

      function evaluateSimpleExpression(raw) {
        const sanitized = sanitizeExpression(raw);
        if (!sanitized) {
          return { error: "Bitte eine Rechnung eingeben." };
        }
        if (!/^[0-9+\-*/().\s]+$/.test(sanitized)) {
          return { error: "Ungueltige Zeichen in der Rechnung." };
        }
        let result = null;
        try {
          result = Function(`"use strict"; return (${sanitized});`)();
        } catch (error) {
          return { error: "Die Rechnung ist so nicht gueltig." };
        }
        if (!Number.isFinite(result)) {
          return { error: "Die Rechnung ist so nicht gueltig." };
        }
        return { result, expression: sanitized };
      }

      function updateSimpleDisplay() {
        if (simpleCalcState.lines.length === 0) {
          simpleCalcLines.innerHTML = "<div class=\"calc-line\">Noch keine Rechnung.</div>";
          return;
        }
        simpleCalcLines.innerHTML = simpleCalcState.lines
          .map(
            (line, index) =>
              `<div class="calc-row">
                <span class="calc-line">${index + 1}) ${line.expression} = ${formatNumber(line.result, 4)}</span>
                <div class="calc-row-actions">
                  <button type="button" class="secondary" data-result="${line.result}">Ergebnis einfuegen</button>
                  <button type="button" class="secondary" data-delete="${index}">Loeschen</button>
                </div>
              </div>`
          )
          .join("");
      }

      function updateSimplePreview() {
        const raw = simpleExpr.value.trim();
        if (!raw) {
          simpleCalcPreview.textContent = "Vorschau: (leer)";
          return;
        }
        const evaluation = evaluateSimpleExpression(raw);
        if (evaluation.error) {
          simpleCalcPreview.textContent = "Vorschau: (ungueltig)";
          return;
        }
        simpleCalcPreview.textContent = `Vorschau: ${evaluation.expression} = ${formatNumber(evaluation.result, 4)}`;
      }

      function insertAtCursor(input, text) {
        const start = input.selectionStart ?? input.value.length;
        const end = input.selectionEnd ?? input.value.length;
        const before = input.value.slice(0, start);
        const after = input.value.slice(end);
        input.value = `${before}${text}${after}`;
        const nextPos = start + text.length;
        input.setSelectionRange(nextPos, nextPos);
        input.focus();
      }

      function removeSimpleLine(index) {
        if (!Number.isFinite(index) || index < 0 || index >= simpleCalcState.lines.length) {
          return;
        }
        simpleCalcState.lines.splice(index, 1);
        const lastLine = simpleCalcState.lines[simpleCalcState.lines.length - 1];
        simpleCalcState.lastResult = lastLine ? lastLine.result : null;
        updateSimpleDisplay();
        updateSimplePreview();
      }

      function addSimpleLine() {
        const raw = simpleExpr.value.trim();
        const evaluation = evaluateSimpleExpression(raw);
        if (evaluation.error) {
          simpleCalcMessage.textContent = evaluation.error;
          return;
        }
        simpleCalcState.lines.push({
          expression: evaluation.expression,
          result: evaluation.result,
        });
        simpleCalcState.lastResult = evaluation.result;
        simpleExpr.value = "";
        simpleCalcMessage.textContent = "";
        updateSimpleDisplay();
        updateSimplePreview();
      }

      function resetSimpleCalculator() {
        simpleCalcState.lines = [];
        simpleCalcState.lastResult = null;
        simpleExpr.value = "";
        simpleCalcMessage.textContent = "";
        updateSimpleDisplay();
        updateSimplePreview();
      }

      function updateTermInputs() {
        const type = termType.value;
        const usesKnown = type === "known" || type === "reciprocalKnown";
        const usesLast = type === "last" || type === "reciprocalLast";
        termValueField.classList.toggle("is-hidden", usesKnown || usesLast);
        knownValueField.classList.toggle("is-hidden", !usesKnown);
        updateCalcPreview();
      }

      function updateKnownValues(task) {
        const items = [];

        if (task.given.U !== undefined) {
          items.push({
            key: "U",
            value: task.given.U,
            unit: "V",
            label: `U (${formatNumber(task.given.U)} V)`,
            exprLabel: "U",
          });
        }
        if (task.given.I !== undefined) {
          items.push({
            key: "I",
            value: task.given.I,
            unit: "A",
            label: `I (${formatNumber(task.given.I)} A)`,
            exprLabel: "I",
          });
        }

        items.push({
          key: "Rges",
          value: task.rTotal,
          unit: "Ohm",
          label: `Rges (${formatNumber(task.rTotal)} Ohm)`,
          exprLabel: "Rges",
        });

        collectComponents(task.circuit).forEach((item) => {
          const unit = "Ohm";
          const shortLabel = item.id;
          const name = item.type === "lamp" ? "Lampe" : "Widerstand";
          items.push({
            key: item.id,
            value: item.value,
            unit,
            label: `${shortLabel} (${name} ${formatNumber(item.value)} Ohm)`,
            exprLabel: shortLabel,
          });
        });

        knownValues = items;
        knownValueSelect.innerHTML = items
          .map((item, index) => `<option value="${index}">${item.label}</option>`)
          .join("");
        knownValueSelect.value = "0";
      }

      function buildTermFromUi() {
        const type = termType.value;
        const isReciprocal =
          type === "reciprocal" || type === "reciprocalKnown" || type === "reciprocalLast";
        let baseValue = null;
        let display = "";

        if (type === "number" || type === "reciprocal") {
          baseValue = parseInput(termValue.value.trim());
          if (Number.isNaN(baseValue)) {
            return { error: "Bitte eine gueltige Zahl eingeben." };
          }
          display = formatNumber(baseValue);
        } else if (type === "known" || type === "reciprocalKnown") {
          const item = knownValues[Number(knownValueSelect.value)];
          if (!item) {
            return { error: "Bitte einen bekannten Wert auswaehlen." };
          }
          baseValue = item.value;
          display = item.exprLabel;
        } else {
          if (calcState.lastResult === null) {
            return { error: "Noch kein Ergebnis vorhanden." };
          }
          baseValue = calcState.lastResult;
          display = "Ans";
        }

        if (isReciprocal) {
          if (baseValue === 0) {
            return { error: "Durch 0 teilen ist nicht erlaubt." };
          }
          return { value: 1 / baseValue, display: `1/${display}` };
        }

        return { value: baseValue, display };
      }

      function getPendingTerm() {
        const type = termType.value;
        if ((type === "number" || type === "reciprocal") && termValue.value.trim() === "") {
          return null;
        }
        return buildTermFromUi();
      }

      function tokensToExpression(tokens) {
        if (tokens.length === 0) {
          return "(leer)";
        }
        let text = "";
        tokens.forEach((token, index) => {
          if (index > 0) {
            const op = tokens[index - 1].nextOperator;
            if (op && op !== "=") {
              text += ` ${op} `;
            }
          }
          text += token.display;
        });
        return text;
      }

      function evaluateTokens(tokens) {
        if (tokens.length === 0) {
          return null;
        }
        const values = tokens.map((token) => token.value);
        const ops = [];
        for (let i = 0; i < tokens.length - 1; i += 1) {
          const op = tokens[i].nextOperator;
          if (op === "=") {
            break;
          }
          ops.push(op);
        }

        let workingValues = [values[0]];
        let workingOps = [];

        for (let i = 0; i < ops.length; i += 1) {
          const op = ops[i];
          const nextValue = values[i + 1];
          if (op === "*" || op === "/") {
            const previous = workingValues.pop();
            if (op === "/" && nextValue === 0) {
              return NaN;
            }
            const result = op === "*" ? previous * nextValue : previous / nextValue;
            workingValues.push(result);
          } else {
            workingValues.push(nextValue);
            workingOps.push(op);
          }
        }

        let result = workingValues[0];
        for (let i = 0; i < workingOps.length; i += 1) {
          result = workingOps[i] === "+" ? result + workingValues[i + 1] : result - workingValues[i + 1];
        }
        return result;
      }

      function updateCalcDisplay() {
        const expression = tokensToExpression(calcState.currentTokens);
        calcCurrent.textContent = `Aktuelle Zeile: ${expression}`;
        if (calcState.lines.length === 0) {
          calcLines.innerHTML = "<div class=\"calc-line\">Noch keine Rechnung.</div>";
          return;
        }
        calcLines.innerHTML = calcState.lines
          .map(
            (line, index) =>
              `<div class="calc-row">
                <span class="calc-line">${index + 1}) ${line.expression} = ${formatNumber(line.result, 4)}</span>
                <div class="calc-row-actions">
                  <button type="button" class="secondary" data-result="${line.result}">Ergebnis einfuegen</button>
                  <button type="button" class="secondary" data-delete="${index}">Loeschen</button>
                </div>
              </div>`
          )
          .join("");
      }

      function updateCalcPreview() {
        const previewTokens = [...calcState.currentTokens];
        const pending = getPendingTerm();
        if (pending && pending.error) {
          calcPreview2.textContent = "Vorschau: (ungueltig)";
          return;
        }
        if (pending && !pending.error) {
          previewTokens.push({ value: pending.value, display: pending.display, nextOperator: "=" });
        }
        if (previewTokens.length === 0) {
          calcPreview2.textContent = "Vorschau: (leer)";
          return;
        }
        const expression = tokensToExpression(previewTokens);
        const result = evaluateTokens(previewTokens);
        if (!Number.isFinite(result)) {
          calcPreview2.textContent = `Vorschau: ${expression} = (ungueltig)`;
          return;
        }
        calcPreview2.textContent = `Vorschau: ${expression} = ${formatNumber(result, 4)}`;
      }

      let suppressOperatorCommit = false;

      function setOperatorValue(value) {
        suppressOperatorCommit = true;
        operatorSelect.value = value;
        suppressOperatorCommit = false;
      }

      function finalizeCurrentLine() {
        if (calcState.currentTokens.length === 0) {
          calcMessage.textContent = "Bitte erst einen Term hinzufuegen.";
          return;
        }
        const result = evaluateTokens(calcState.currentTokens);
        if (!Number.isFinite(result)) {
          calcMessage.textContent = "Die Rechnung ist so nicht gueltig.";
          return;
        }
        const expression = tokensToExpression(calcState.currentTokens);
        calcState.lines.push({ expression, result });
        calcState.lastResult = result;
        calcState.currentTokens = [];
        calcMessage.textContent = "";
        setOperatorValue("+");
        updateCalcDisplay();
        updateCalcPreview();
      }

      function commitTermFromUi(nextOperatorOverride) {
        const term = getPendingTerm();
        if (!term) {
          calcMessage.textContent = "Bitte zuerst einen Term eingeben.";
          return false;
        }
        if (term.error) {
          calcMessage.textContent = term.error;
          return false;
        }
        const nextOperator = nextOperatorOverride || operatorSelect.value;
        calcState.currentTokens.push({
          value: term.value,
          display: term.display,
          nextOperator,
        });
        if (termType.value === "number" || termType.value === "reciprocal") {
          termValue.value = "";
        }
        calcMessage.textContent = "";
        updateCalcDisplay();
        updateCalcPreview();
        return true;
      }

      function commitLineFromUi() {
        const pending = getPendingTerm();
        if (pending && pending.error) {
          calcMessage.textContent = pending.error;
          return;
        }
        if (pending && !pending.error) {
          calcState.currentTokens.push({
            value: pending.value,
            display: pending.display,
            nextOperator: "=",
          });
          if (termType.value === "number" || termType.value === "reciprocal") {
            termValue.value = "";
          }
        }
        finalizeCurrentLine();
      }

      function insertIntoVariant2(value) {
        termType.value = "number";
        termValue.value = formatNumber(value, 4);
        updateTermInputs();
        termValue.focus();
      }

      function removeCalcLine(index) {
        if (!Number.isFinite(index) || index < 0 || index >= calcState.lines.length) {
          return;
        }
        calcState.lines.splice(index, 1);
        const lastLine = calcState.lines[calcState.lines.length - 1];
        calcState.lastResult = lastLine ? lastLine.result : null;
        updateCalcDisplay();
      }

      function undoLastTerm() {
        if (calcState.currentTokens.length === 0) {
          calcMessage.textContent = "Keine Terme zum Entfernen.";
          return;
        }
        calcState.currentTokens.pop();
        calcMessage.textContent = "";
        updateCalcDisplay();
        updateCalcPreview();
      }

      function resetCalculator(task) {
        calcState.lines = [];
        calcState.currentTokens = [];
        calcState.lastResult = null;
        updateKnownValues(task);
        termType.value = "number";
        termValue.value = "";
        setOperatorValue("+");
        calcMessage.textContent = "";
        updateTermInputs();
        updateCalcDisplay();
        updateCalcPreview();
      }

      function makeComponent(index) {
        const isLamp = Math.random() < 0.25;
        if (isLamp) {
          return { id: "L" + index, type: "lamp", value: LAMP_RESISTANCE };
        }
        return { id: "R" + index, type: "resistor", value: pick(RESISTOR_VALUES) };
      }

      function makeSeriesCircuit() {
        const count = randomInt(1, 4);
        const items = [];
        for (let i = 0; i < count; i += 1) {
          items.push(makeComponent(i + 1));
        }
        return { type: "series", series: items };
      }

      function makeParallelCircuit() {
        const branches = randomInt(1, 5);
        const items = [];
        for (let i = 0; i < branches; i += 1) {
          items.push(makeComponent(i + 1));
        }
        return { type: "parallel", parallel: items };
      }

      function makeComboCircuit() {
        const seriesTotal = randomInt(1, 2);
        const beforeCount = randomInt(0, seriesTotal);
        const afterCount = seriesTotal - beforeCount;
        const seriesBefore = [];
        const seriesAfter = [];
        const parallelCount = randomInt(2, 3);
        let index = 1;

        for (let i = 0; i < beforeCount; i += 1) {
          seriesBefore.push(makeComponent(index));
          index += 1;
        }

        const parallel = [];
        for (let i = 0; i < parallelCount; i += 1) {
          parallel.push(makeComponent(index));
          index += 1;
        }

        for (let i = 0; i < afterCount; i += 1) {
          seriesAfter.push(makeComponent(index));
          index += 1;
        }

        if (seriesBefore.length === 0 && seriesAfter.length === 0) {
          seriesBefore.push(makeComponent(index));
        }

        return {
          type: "combo",
          seriesBefore,
          parallel,
          seriesAfter,
        };
      }

      function buildCircuit() {
        const roll = Math.random();
        if (roll < 0.33) {
          return makeSeriesCircuit();
        }
        if (roll < 0.66) {
          return makeParallelCircuit();
        }
        return makeComboCircuit();
      }

      function sumResistance(items) {
        return items.reduce((sum, item) => sum + item.value, 0);
      }

      function parallelResistance(items) {
        const inv = items.reduce((sum, item) => sum + 1 / item.value, 0);
        return 1 / inv;
      }

      function circuitResistance(circuit) {
        if (circuit.type === "series") {
          return sumResistance(circuit.series);
        }
        if (circuit.type === "parallel") {
          return parallelResistance(circuit.parallel);
        }
        const seriesTotal = sumResistance(circuit.seriesBefore) + sumResistance(circuit.seriesAfter);
        return seriesTotal + parallelResistance(circuit.parallel);
      }

      function describeCircuit(circuit) {
        if (circuit.type === "series") {
          return "Reihenschaltung";
        }
        if (circuit.type === "parallel") {
          return "Parallelschaltung";
        }
        return "Reihe + Parallel";
      }

      function collectComponents(circuit) {
        if (circuit.type === "series") return circuit.series;
        if (circuit.type === "parallel") return circuit.parallel;
        return [...circuit.seriesBefore, ...circuit.parallel, ...circuit.seriesAfter];
      }

      function buildLegend(circuit) {
        const items = collectComponents(circuit).map((item) => {
          const label = item.type === "lamp" ? "Lampe" : "Widerstand";
          return `${item.id}: ${label} ${item.value} Ohm`;
        });
        circuitLegend.innerHTML = items.map((text) => `<span>${text}</span>`).join("");
      }

      function formatList(values) {
        return values.map((value) => formatNumber(value)).join(" + ");
      }

      function buildResistanceSteps(circuit) {
        const steps = [];
        let total = 0;

        if (circuit.type === "series") {
          const values = circuit.series.map((item) => item.value);
          total = sumResistance(circuit.series);
          steps.push(`Rges = ${formatList(values)} = ${formatNumber(total)} Ohm`);
          return { steps, total };
        }

        if (circuit.type === "parallel") {
          const values = circuit.parallel.map((item) => item.value);
          const invValues = values.map((value) => 1 / value);
          const invSum = invValues.reduce((sum, value) => sum + value, 0);
          total = 1 / invSum;
          steps.push(`1 / Rges = ${values.map((value) => `1/${value}`).join(" + ")}`);
          steps.push(
            `1 / Rges = ${invValues.map((value) => formatNumber(value, 3)).join(" + ")} = ${formatNumber(invSum, 3)}`
          );
          steps.push(`Rges = 1 / ${formatNumber(invSum, 3)} = ${formatNumber(total)} Ohm`);
          return { steps, total };
        }

        const seriesValues = [...circuit.seriesBefore, ...circuit.seriesAfter].map((item) => item.value);
        const seriesTotal = sumResistance(circuit.seriesBefore) + sumResistance(circuit.seriesAfter);
        const parallelValues = circuit.parallel.map((item) => item.value);
        const parallelInvValues = parallelValues.map((value) => 1 / value);
        const parallelInvSum = parallelInvValues.reduce((sum, value) => sum + value, 0);
        const parallelTotal = 1 / parallelInvSum;
        total = seriesTotal + parallelTotal;
        if (seriesValues.length > 0) {
          steps.push(`Rserie = ${formatList(seriesValues)} = ${formatNumber(seriesTotal)} Ohm`);
        }
        steps.push(`1 / Rparallel = ${parallelValues.map((value) => `1/${value}`).join(" + ")}`);
        steps.push(
          `1 / Rparallel = ${parallelInvValues.map((value) => formatNumber(value, 3)).join(" + ")} = ${formatNumber(parallelInvSum, 3)}`
        );
        steps.push(`Rparallel = 1 / ${formatNumber(parallelInvSum, 3)} = ${formatNumber(parallelTotal)} Ohm`);
        steps.push(`Rges = ${formatNumber(seriesTotal)} + ${formatNumber(parallelTotal)} = ${formatNumber(total)} Ohm`);
        return { steps, total };
      }

      function pickReasonableValue(values, min, max, computeFn) {
        for (let attempt = 0; attempt < 12; attempt += 1) {
          const candidate = pick(values);
          const result = computeFn(candidate);
          if (result >= min && result <= max) {
            return { candidate, result };
          }
        }
        const candidate = pick(values);
        return { candidate, result: computeFn(candidate) };
      }

      function buildTask(force = false) {
        if (taskInitialized && !force) {
          return;
        }
        taskSolved = false;
        rankMessage.textContent = "";
        const circuit = buildCircuit();
        const rTotal = circuitResistance(circuit);
        const mode = modeSelect.value === "random" ? pick(["U", "I", "R"]) : modeSelect.value;
        let given = {};
        let expected = 0;
        let unit = "";

        if (mode === "U") {
          const pickCurrent = pickReasonableValue(CURRENTS, 1, 30, (i) => rTotal * i);
          given = { I: pickCurrent.candidate };
          expected = pickCurrent.result;
          unit = "V";
          taskText.textContent = "Berechne die Gesamtspannung U.";
        } else if (mode === "I") {
          const pickVoltage = pickReasonableValue(VOLTAGES, 0.05, 2.5, (u) => u / rTotal);
          given = { U: pickVoltage.candidate };
          expected = pickVoltage.result;
          unit = "A";
          taskText.textContent = "Berechne die Gesamtstromstaerke I.";
        } else {
          const pickCurrent = pickReasonableValue(CURRENTS, 1, 30, (i) => rTotal * i);
          given = { U: pickCurrent.result, I: pickCurrent.candidate };
          expected = given.U / given.I;
          unit = "Ohm";
          taskText.textContent = "Berechne den Gesamtwiderstand Rges.";
        }

        const givenLines = [];
        if (given.U !== undefined) {
          givenLines.push(`Gesamtspannung U = ${formatNumber(given.U)} V`);
        }
        if (given.I !== undefined) {
          givenLines.push(`Gesamtstrom I = ${formatNumber(given.I)} A`);
        }
        const hasLamp = collectComponents(circuit).some((item) => item.type === "lamp");
        if (hasLamp) {
          givenLines.push("Lampe: fester Widerstand 60 Ohm (bei Betriebstemperatur)");
        }
        givenLines.push(`Schaltung: ${describeCircuit(circuit)}`);

        givenText.innerHTML = `<ul>${givenLines.map((line) => `<li>${line}</li>`).join("")}</ul>`;
        unitLabel.textContent = unit;
        answerInput.value = "";
        feedback.textContent = "";
        feedback.className = "feedback";
        solution.innerHTML = "";

        buildLegend(circuit);
        drawCircuit(circuit);

        currentTask = {
          circuit,
          mode,
          expected,
          given,
          unit,
          rTotal,
        };
        taskInitialized = true;
        resetSimpleCalculator();
        resetCalculator(currentTask);
      }

      function drawCircuit(circuit) {
        const shapes = [];
        const wireColor = getComputedStyle(document.documentElement).getPropertyValue("--wire").trim();

        function wire(x1, y1, x2, y2) {
          shapes.push(
            `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${wireColor}" stroke-width="3" />`
          );
        }

        function resistor(x, y) {
          shapes.push(`<rect x="${x - 30}" y="${y - 12}" width="60" height="24" rx="4" ry="4"
            fill="#f8efe0" stroke="${wireColor}" stroke-width="2" />`);
        }

        function lamp(x, y) {
          shapes.push(`<circle cx="${x}" cy="${y}" r="14" fill="#fff6d6" stroke="${wireColor}" stroke-width="2" />`);
          shapes.push(`<line x1="${x - 8}" y1="${y - 8}" x2="${x + 8}" y2="${y + 8}" stroke="${wireColor}" stroke-width="2" />`);
          shapes.push(`<line x1="${x - 8}" y1="${y + 8}" x2="${x + 8}" y2="${y - 8}" stroke="${wireColor}" stroke-width="2" />`);
        }

        function drawComponent(comp, x, y, labelOffsetY = 36) {
          const label = `${comp.id} ${comp.value} Ohm`;
          if (comp.type === "lamp") {
            lamp(x, y);
          } else {
            resistor(x, y);
          }
          shapes.push(
            `<text x="${x}" y="${y + labelOffsetY}" text-anchor="middle" font-size="12" fill="${wireColor}">${label}</text>`
          );
        }

        const centerY = 240;
        const leftX = 40;
        const rightX = 600;
        const loopBottom = 440;

        function battery(x, y) {
          shapes.push(
            `<line x1="${x}" y1="${y - 24}" x2="${x}" y2="${y + 24}" stroke="${wireColor}" stroke-width="3" />`
          );
          shapes.push(
            `<line x1="${x + 12}" y1="${y - 14}" x2="${x + 12}" y2="${y + 14}" stroke="${wireColor}" stroke-width="3" />`
          );
          shapes.push(`<text x="${x - 10}" y="${y - 30}" font-size="12" fill="${wireColor}">+</text>`);
          shapes.push(`<text x="${x - 10}" y="${y + 44}" font-size="12" fill="${wireColor}">-</text>`);
        }

        function branchPositions(count, center, spacing) {
          if (count <= 1) {
            return [center];
          }
          const totalSpan = spacing * (count - 1);
          const start = center - totalSpan / 2;
          return Array.from({ length: count }, (_, index) => start + spacing * index);
        }

        wire(leftX, centerY, leftX, loopBottom);
        wire(leftX, loopBottom, rightX, loopBottom);
        wire(rightX, loopBottom, rightX, centerY);
        battery(leftX + 26, centerY);
        if (circuit.type === "series") {
          const y = centerY;
          const items = circuit.series;
          wire(leftX, y, rightX, y);
          const span = (rightX - leftX - 80) / (items.length + 1);
          items.forEach((item, index) => {
            const x = leftX + 40 + span * (index + 1);
            drawComponent(item, x, y);
          });
        } else if (circuit.type === "parallel") {
          const left = 160;
          const right = 480;
          wire(leftX, centerY, left, centerY);
          wire(right, centerY, rightX, centerY);
          const items = circuit.parallel;
          const spacing = 78;
          const positions = branchPositions(items.length, centerY, spacing);
          const railTop = items.length === 1 ? positions[0] - 40 : positions[0];
          const railBottom = items.length === 1 ? positions[0] + 40 : positions[positions.length - 1];
          wire(left, railTop, left, railBottom);
          wire(right, railTop, right, railBottom);
          items.forEach((item, index) => {
            const y = positions[index];
            wire(left, y, right, y);
            drawComponent(item, (left + right) / 2, y, 36);
          });
        } else {
          const y = centerY;
          const before = circuit.seriesBefore;
          const after = circuit.seriesAfter;
          const minSpacingX = 90;
          const leftMargin = 60;
          const rightMargin = 40;
          let leftRail = Math.max(260, leftMargin + minSpacingX * (before.length + 1));
          let rightRail = Math.min(420, rightX - rightMargin - minSpacingX * (after.length + 1));
          if (rightRail - leftRail < 120) {
            rightRail = leftRail + 120;
          }
          wire(leftX, y, leftRail, y);
          wire(rightRail, y, rightX, y);

          if (before.length > 0) {
            const span = (leftRail - leftMargin) / (before.length + 1);
            before.forEach((item, index) => {
              drawComponent(item, leftMargin + span * (index + 1), y);
            });
          }
          if (after.length > 0) {
            const span = (rightX - rightRail - rightMargin) / (after.length + 1);
            after.forEach((item, index) => {
              drawComponent(item, rightRail + rightMargin + span * (index + 1), y);
            });
          }

          const branches = circuit.parallel;
          const spacing = 78;
          const positions = branchPositions(branches.length, y, spacing);
          const railTop = positions[0];
          const railBottom = positions[positions.length - 1];
          wire(leftRail, railTop, leftRail, railBottom);
          wire(rightRail, railTop, rightRail, railBottom);
          branches.forEach((item, index) => {
            const yBranch = positions[index];
            wire(leftRail, yBranch, rightRail, yBranch);
            drawComponent(item, (leftRail + rightRail) / 2, yBranch, 36);
          });
        }

        circuitSvg.innerHTML = shapes.join("");
      }

      function buildSolution(task) {
        const { steps, total } = buildResistanceSteps(task.circuit);
        const solutionBlocks = [];

        solutionBlocks.push(`
          <div class="solution-block">
            <div class="solution-title">1) Gesamtwiderstand</div>
            <div>${steps.join("<br>")}</div>
          </div>
        `);

        if (task.mode === "U") {
          solutionBlocks.push(`
            <div class="solution-block">
              <div class="solution-title">2) Spannung</div>
              <div>U = Rges * I = ${formatNumber(total)} Ohm * ${formatNumber(task.given.I)} A = ${formatNumber(task.expected)} V</div>
            </div>
          `);
        } else if (task.mode === "I") {
          solutionBlocks.push(`
            <div class="solution-block">
              <div class="solution-title">2) Stromstaerke</div>
              <div>I = U / Rges = ${formatNumber(task.given.U)} V / ${formatNumber(total)} Ohm = ${formatNumber(task.expected)} A</div>
            </div>
          `);
        } else {
          solutionBlocks.push(`
            <div class="solution-block">
              <div class="solution-title">2) Widerstand</div>
              <div>R = U / I = ${formatNumber(task.given.U)} V / ${formatNumber(task.given.I)} A = ${formatNumber(task.expected)} Ohm</div>
              <div>Rges aus dem Schaltplan sollte denselben Wert liefern.</div>
            </div>
          `);
        }

        return solutionBlocks.join("");
      }

      function checkAnswer() {
        if (!currentTask) return;
        const inputValue = parseInput(answerInput.value.trim());
        if (Number.isNaN(inputValue)) {
          feedback.textContent = "Bitte gib eine Zahl ein (Komma oder Punkt erlaubt).";
          feedback.className = "feedback bad";
          return;
        }

        const expected = currentTask.expected;
        const tolerance = Math.max(0.02, Math.abs(expected) * 0.02);
        const delta = Math.abs(inputValue - expected);

        if (delta <= tolerance) {
          feedback.textContent = "Richtig! Gut gerechnet.";
          feedback.className = "feedback good";
          registerCorrectAnswer();
        } else {
          feedback.textContent = `Leider falsch. Richtiger Wert: ${formatNumber(expected)} ${currentTask.unit}.`;
          feedback.className = "feedback bad";
        }

        solution.innerHTML = buildSolution(currentTask);
      }

      document.getElementById("checkBtn").addEventListener("click", checkAnswer);
      document.getElementById("newBtn").addEventListener("click", () => buildTask(true));
      calcToggleButtons.forEach((button) => {
        button.addEventListener("click", () => {
          setCalcVariant(button.dataset.variant);
        });
      });
      simpleCalcBtn.addEventListener("click", addSimpleLine);
      rankApplyBtn.addEventListener("click", applyRankSelection);
      termType.addEventListener("change", updateTermInputs);
      calcAddTermBtn.addEventListener("click", () => {
        if (operatorSelect.value === "=") {
          calcMessage.textContent = "Operator darf nicht '=' sein.";
          return;
        }
        commitTermFromUi(operatorSelect.value);
      });
      calcFinishBtn.addEventListener("click", commitLineFromUi);
      calcUndoBtn.addEventListener("click", undoLastTerm);
      operatorSelect.addEventListener("change", () => {
        if (suppressOperatorCommit) {
          return;
        }
        updateCalcPreview();
      });
      knownValueSelect.addEventListener("change", updateCalcPreview);
      answerInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          checkAnswer();
        }
      });

      simpleExpr.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          addSimpleLine();
        }
      });

      simpleExpr.addEventListener("input", () => {
        updateSimplePreview();
        simpleCalcMessage.textContent = "";
      });

      termValue.addEventListener("input", () => {
        updateCalcPreview();
        calcMessage.textContent = "";
      });

      termValue.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          if (operatorSelect.value === "=") {
            calcMessage.textContent = "Operator darf nicht '=' sein.";
          } else {
            commitTermFromUi(operatorSelect.value);
          }
        }
      });

      operatorSelect.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          if (operatorSelect.value === "=") {
            calcMessage.textContent = "Operator darf nicht '=' sein.";
          } else {
            commitTermFromUi(operatorSelect.value);
          }
        }
      });

      simpleCalcLines.addEventListener("click", (event) => {
        const resultButton = event.target.closest("button[data-result]");
        if (resultButton) {
          const value = Number(resultButton.dataset.result);
          if (!Number.isFinite(value)) return;
          insertAtCursor(simpleExpr, formatNumber(value, 4));
          updateSimplePreview();
          return;
        }
        const deleteButton = event.target.closest("button[data-delete]");
        if (!deleteButton) return;
        const index = Number(deleteButton.dataset.delete);
        removeSimpleLine(index);
      });

      calcLines.addEventListener("click", (event) => {
        const resultButton = event.target.closest("button[data-result]");
        if (resultButton) {
          const value = Number(resultButton.dataset.result);
          if (!Number.isFinite(value)) return;
          insertIntoVariant2(value);
          return;
        }
        const deleteButton = event.target.closest("button[data-delete]");
        if (!deleteButton) return;
        const index = Number(deleteButton.dataset.delete);
        removeCalcLine(index);
      });

      populateRankSelect();
      correctCount = Math.max(0, readStoredCount());
      updateRankUi(false);
      setCalcVariant(activeCalcVariant);
      buildTask();
    </script>
  </body>
</html>
